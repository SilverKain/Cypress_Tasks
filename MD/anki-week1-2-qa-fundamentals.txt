#separator:tab
#html:true
#tags:QA-Fundamentals Week1-2 Trainee

# ===== БАЗОВЫЕ ПОНЯТИЯ QA =====

Quality Assurance (QA)	<b>Обеспечение качества</b> — процесс, направленный на предотвращение дефектов в продукте.<br><br><b>Примеры задач:</b><br>1. Разработка стандартов качества<br>2. Внедрение процессов тестирования<br>3. Аудит и улучшение процессов разработки

Quality Control (QC)	<b>Контроль качества</b> — процесс выявления дефектов в готовом продукте через тестирование.<br><br><b>Отличие от QA:</b> QA — предотвращение, QC — обнаружение

Testing (Тестирование)	<b>Тестирование</b> — процесс выполнения программы с целью обнаружения ошибок.<br><br><b>Цели:</b><br>1. Найти дефекты<br>2. Убедиться в соответствии требованиям<br>3. Оценить качество продукта

Bug (Дефект/Баг)	<b>Дефект (Bug)</b> — несоответствие между фактическим и ожидаемым поведением системы.<br><br><b>Примеры:</b><br>• Кнопка не работает<br>• Неправильный расчет<br>• Ошибка при сохранении

Error (Ошибка)	<b>Ошибка (Error)</b> — действие человека, которое приводит к неправильному результату.<br><br><b>Пример:</b> Разработчик неправильно написал условие в коде

Failure (Отказ)	<b>Отказ (Failure)</b> — проявление дефекта во время работы системы, видимое пользователю.<br><br><b>Пример:</b> Система зависла при оплате заказа

Defect (Дефект)	<b>Дефект (Defect)</b> — недостаток в компоненте или системе, который может привести к невыполнению требуемой функции.<br><br><b>Синонимы:</b> баг, ошибка, проблема, issue

Test Case (Тест-кейс)	<b>Тест-кейс</b> — набор условий и шагов для проверки определённой функциональности.<br><br><b>Структура:</b><br>• ID и название<br>• Предусловия<br>• Шаги<br>• Ожидаемый результат

Test Suite (Набор тестов)	<b>Test Suite</b> — коллекция тест-кейсов, объединённых по определённому признаку.<br><br><b>Примеры:</b><br>• Регрессионный набор<br>• Smoke тесты<br>• Тесты модуля оплаты

Test Plan (Тест-план)	<b>Тест-план</b> — документ, описывающий стратегию, ресурсы и расписание тестирования.<br><br><b>Содержит:</b><br>• Объём тестирования<br>• Критерии входа/выхода<br>• Риски и митигации

Test Strategy (Тест-стратегия)	<b>Тест-стратегия</b> — высокоуровневый документ, определяющий подход к тестированию на уровне организации/проекта.<br><br><b>Отличие от Test Plan:</b> Стратегия — общий подход, План — конкретные действия

Requirement (Требование)	<b>Требование</b> — описание того, что система должна делать или какой характеристикой обладать.<br><br><b>Типы:</b><br>• Функциональные<br>• Нефункциональные<br>• Бизнес-требования

Specification (Спецификация)	<b>Спецификация</b> — детальное описание требований к системе, её поведению и характеристикам.<br><br><b>Примеры:</b><br>• SRS (Software Requirements Specification)<br>• Функциональная спецификация

# ===== 7 ПРИНЦИПОВ ТЕСТИРОВАНИЯ =====

Принцип 1: Тестирование показывает наличие дефектов	<b>Testing shows the presence of defects</b><br><br>Тестирование может показать, что дефекты есть, но не может доказать их отсутствие.<br><br><b>Вывод:</b> Даже успешное тестирование не гарантирует 100% качества

Принцип 2: Исчерпывающее тестирование невозможно	<b>Exhaustive testing is impossible</b><br><br>Невозможно протестировать все комбинации входных данных и условий.<br><br><b>Решение:</b> Использовать анализ рисков и приоритизацию

Принцип 3: Раннее тестирование	<b>Early testing</b><br><br>Тестирование должно начинаться как можно раньше в жизненном цикле разработки.<br><br><b>Причина:</b> Чем раньше найден дефект, тем дешевле его исправить

Принцип 4: Скопление дефектов	<b>Defect clustering</b><br><br>Небольшое количество модулей содержит большинство дефектов (принцип Парето 80/20).<br><br><b>Применение:</b> Фокусируй тестирование на проблемных областях

Принцип 5: Парадокс пестицида	<b>Pesticide paradox</b><br><br>Повторяющиеся одни и те же тесты перестают находить новые дефекты.<br><br><b>Решение:</b> Регулярно обновляй и расширяй тест-кейсы

Принцип 6: Тестирование зависит от контекста	<b>Testing is context dependent</b><br><br>Подход к тестированию зависит от типа проекта, рисков и требований.<br><br><b>Пример:</b> Тестирование медицинского ПО отличается от тестирования игры

Принцип 7: Заблуждение об отсутствии ошибок	<b>Absence-of-errors fallacy</b><br><br>Даже система без багов бесполезна, если не соответствует потребностям пользователей.<br><br><b>Вывод:</b> Важно тестировать не только на ошибки, но и на соответствие требованиям

# ===== УРОВНИ ТЕСТИРОВАНИЯ =====

Unit Testing (Модульное тестирование)	<b>Unit Testing</b> — тестирование отдельных компонентов/модулей программы изолированно.<br><br><b>Кто выполняет:</b> Разработчики<br><b>Цель:</b> Проверить, что каждый модуль работает корректно

Integration Testing (Интеграционное тестирование)	<b>Integration Testing</b> — тестирование взаимодействия между модулями системы.<br><br><b>Подходы:</b><br>• Big Bang<br>• Top-Down<br>• Bottom-Up<br>• Sandwich

System Testing (Системное тестирование)	<b>System Testing</b> — тестирование полностью интегрированной системы на соответствие требованиям.<br><br><b>Кто выполняет:</b> QA-команда<br><b>Охват:</b> Функциональные и нефункциональные требования

Acceptance Testing (Приёмочное тестирование)	<b>Acceptance Testing</b> — тестирование системы с точки зрения конечного пользователя/заказчика.<br><br><b>Типы:</b><br>• UAT (User Acceptance Testing)<br>• Alpha/Beta тестирование<br>• Контрактное приёмочное

UAT (User Acceptance Testing)	<b>UAT</b> — приёмочное тестирование пользователями для подтверждения соответствия бизнес-требованиям.<br><br><b>Кто выполняет:</b> Заказчик, бизнес-пользователи<br><b>Цель:</b> Подтвердить готовность к релизу

Alpha Testing (Альфа-тестирование)	<b>Alpha Testing</b> — тестирование внутри организации-разработчика перед выпуском продукта.<br><br><b>Участники:</b> Внутренние сотрудники, не входящие в команду разработки

Beta Testing (Бета-тестирование)	<b>Beta Testing</b> — тестирование продукта реальными пользователями в реальных условиях.<br><br><b>Цель:</b> Получить обратную связь перед официальным релизом

# ===== ВИДЫ ТЕСТИРОВАНИЯ =====

Functional Testing (Функциональное тестирование)	<b>Функциональное тестирование</b> — проверка того, ЧТО делает система, соответствие функциональным требованиям.<br><br><b>Примеры проверок:</b><br>• Авторизация работает<br>• Заказ создаётся<br>• Email отправляется

Non-Functional Testing (Нефункциональное тестирование)	<b>Нефункциональное тестирование</b> — проверка КАК работает система (производительность, безопасность, удобство).<br><br><b>Типы:</b><br>• Performance<br>• Security<br>• Usability<br>• Compatibility

Smoke Testing (Дымовое тестирование)	<b>Smoke Testing</b> — быстрая проверка основного функционала после сборки/деплоя.<br><br><b>Когда применять:</b> После каждого билда<br><b>Цель:</b> Убедиться, что система "не дымит" (работает базово)

Sanity Testing (Санитарное тестирование)	<b>Sanity Testing</b> — проверка конкретной функциональности после небольших изменений.<br><br><b>Отличие от Smoke:</b> Sanity — узкий фокус, Smoke — широкий охват

Regression Testing (Регрессионное тестирование)	<b>Regression Testing</b> — проверка того, что новые изменения не сломали существующую функциональность.<br><br><b>Когда применять:</b> После каждого изменения кода<br><b>Важно:</b> Автоматизируй регрессию!

Re-testing (Повторное тестирование)	<b>Re-testing</b> — повторная проверка исправленного дефекта.<br><br><b>Отличие от Regression:</b><br>• Re-testing — проверяем конкретный баг<br>• Regression — проверяем всё вокруг

Exploratory Testing (Исследовательское тестирование)	<b>Exploratory Testing</b> — одновременное изучение системы, разработка и выполнение тестов.<br><br><b>Характеристики:</b><br>• Минимум документации<br>• Креативный подход<br>• Опыт тестировщика важен

Ad-hoc Testing	<b>Ad-hoc Testing</b> — неструктурированное тестирование без документации и планирования.<br><br><b>Отличие от Exploratory:</b> Ad-hoc — хаотичный, Exploratory — структурированный подход

Positive Testing	<b>Positive Testing</b> — тестирование системы с корректными входными данными.<br><br><b>Цель:</b> Подтвердить, что система работает правильно при правильном использовании<br><b>Пример:</b> Логин с верным паролем

Negative Testing	<b>Negative Testing</b> — тестирование системы с некорректными входными данными.<br><br><b>Цель:</b> Проверить, что система корректно обрабатывает ошибки<br><b>Пример:</b> Логин с неверным паролем

End-to-End Testing (E2E)	<b>End-to-End Testing</b> — тестирование полного пользовательского сценария от начала до конца.<br><br><b>Пример:</b> Регистрация → Поиск товара → Корзина → Оплата → Подтверждение

Black Box Testing	<b>Black Box Testing</b> — тестирование без знания внутренней структуры системы.<br><br><b>Фокус:</b> Входы и выходы системы<br><b>Кто использует:</b> QA-инженеры

White Box Testing	<b>White Box Testing</b> — тестирование с доступом к исходному коду и внутренней структуре.<br><br><b>Фокус:</b> Логика кода, ветвления, циклы<br><b>Кто использует:</b> Разработчики

Gray Box Testing	<b>Gray Box Testing</b> — комбинация Black Box и White Box, частичное знание внутренней структуры.<br><br><b>Пример:</b> Тестирование API с пониманием архитектуры БД

# ===== РОЛИ И ОБЯЗАННОСТИ В QA =====

QA Engineer (QA-инженер)	<b>QA Engineer</b> — специалист, отвечающий за качество программного продукта.<br><br><b>Обязанности:</b><br>• Написание тест-кейсов<br>• Выполнение тестирования<br>• Документирование багов<br>• Работа с командой

Test Lead (Тест-лид)	<b>Test Lead</b> — руководитель команды тестирования.<br><br><b>Обязанности:</b><br>• Планирование тестирования<br>• Распределение задач<br>• Отчётность по качеству<br>• Менторинг команды

QA Manager	<b>QA Manager</b> — менеджер отдела качества.<br><br><b>Обязанности:</b><br>• Стратегия QA<br>• Бюджет и ресурсы<br>• Взаимодействие с бизнесом<br>• Развитие процессов

SDET (Software Development Engineer in Test)	<b>SDET</b> — разработчик в тестировании, сочетающий навыки разработки и QA.<br><br><b>Задачи:</b><br>• Автоматизация тестов<br>• Разработка тестовых фреймворков<br>• Code review тестов

# ===== ДОКУМЕНТАЦИЯ В ТЕСТИРОВАНИИ =====

Bug Report (Баг-репорт)	<b>Bug Report</b> — документ, описывающий найденный дефект.<br><br><b>Обязательные поля:</b><br>• Заголовок<br>• Шаги воспроизведения<br>• Ожидаемый результат<br>• Фактический результат<br>• Приоритет/Severity

Severity (Серьёзность бага)	<b>Severity</b> — степень влияния дефекта на систему.<br><br><b>Уровни:</b><br>• Blocker — система не работает<br>• Critical — критическая функция сломана<br>• Major — значительная проблема<br>• Minor — незначительная проблема<br>• Trivial — косметика

Priority (Приоритет бага)	<b>Priority</b> — порядок, в котором дефект должен быть исправлен.<br><br><b>Уровни:</b><br>• P1/High — исправить немедленно<br>• P2/Medium — исправить в текущем спринте<br>• P3/Low — исправить когда будет время

Чем отличается Severity от Priority?	<b>Severity vs Priority:</b><br><br><b>Severity</b> — техническое влияние (устанавливает QA)<br><b>Priority</b> — бизнес-влияние (устанавливает PM/PO)<br><br><b>Пример:</b> Опечатка в логотипе на главной — Low Severity, High Priority

Traceability Matrix (Матрица трассируемости)	<b>Traceability Matrix</b> — документ, связывающий требования с тест-кейсами.<br><br><b>Цель:</b><br>• Убедиться, что все требования покрыты тестами<br>• Отследить влияние изменений требований

Test Execution Report	<b>Test Execution Report</b> — отчёт о результатах выполнения тестов.<br><br><b>Содержит:</b><br>• Количество выполненных тестов<br>• Passed/Failed/Blocked<br>• Найденные дефекты<br>• Рекомендации

# ===== МЕТРИКИ КАЧЕСТВА =====

Test Coverage (Покрытие тестами)	<b>Test Coverage</b> — процент функциональности/кода, покрытого тестами.<br><br><b>Типы:</b><br>• Requirements Coverage<br>• Code Coverage<br>• Branch Coverage

Defect Density	<b>Defect Density</b> — количество дефектов на единицу размера (1000 LOC, модуль).<br><br><b>Формула:</b> Defect Density = Дефекты / Размер<br><b>Применение:</b> Оценка качества кода

Defect Leakage	<b>Defect Leakage</b> — процент дефектов, пропущенных в production.<br><br><b>Формула:</b> (Баги в prod / Всего багов) × 100%<br><b>Цель:</b> Стремиться к 0%

Pass Rate (Процент успешных тестов)	<b>Pass Rate</b> — доля успешно пройденных тест-кейсов.<br><br><b>Формула:</b> (Passed tests / Total tests) × 100%<br><b>Норма:</b> >95% для релиза

# ===== ЖИЗНЕННЫЙ ЦИКЛ ДЕФЕКТА =====

Жизненный цикл дефекта (Bug Lifecycle)	<b>Bug Lifecycle</b> — последовательность статусов дефекта от обнаружения до закрытия.<br><br><b>Типичный цикл:</b><br>New → Open → In Progress → Fixed → Ready for QA → Verified → Closed

Статус: New	<b>New</b> — дефект только что создан, ещё не рассмотрен командой.<br><br><b>Следующие действия:</b> Ревью, назначение разработчику

Статус: Open	<b>Open</b> — дефект принят и ожидает исправления.<br><br><b>Ответственный:</b> Разработчик<br><b>Следующий статус:</b> In Progress

Статус: In Progress	<b>In Progress</b> — разработчик работает над исправлением дефекта.<br><br><b>Следующий статус:</b> Fixed или Won't Fix

Статус: Fixed	<b>Fixed</b> — разработчик исправил дефект, ожидает проверки QA.<br><br><b>Действие QA:</b> Re-testing исправления

Статус: Verified	<b>Verified</b> — QA подтвердил, что дефект исправлен корректно.<br><br><b>Следующий статус:</b> Closed

Статус: Closed	<b>Closed</b> — дефект полностью исправлен и закрыт.<br><br><b>Важно:</b> Дефект может быть переоткрыт (Reopened), если проблема вернулась

Статус: Reopened	<b>Reopened</b> — дефект вернулся после исправления.<br><br><b>Причины:</b><br>• Неполное исправление<br>• Регрессия<br>• Другие условия воспроизведения

Статус: Rejected/Won't Fix	<b>Rejected/Won't Fix</b> — дефект не будет исправлен.<br><br><b>Причины:</b><br>• Работает как задумано (By Design)<br>• Дубликат<br>• Не воспроизводится<br>• Низкий приоритет

Статус: Deferred	<b>Deferred</b> — исправление дефекта отложено на следующий релиз.<br><br><b>Причины:</b><br>• Нехватка времени<br>• Низкий приоритет<br>• Зависимость от других задач

# ===== ТЕСТОВЫЕ СРЕДЫ =====

Development Environment (DEV)	<b>DEV Environment</b> — среда разработки, где программисты пишут и тестируют код.<br><br><b>Характеристики:</b><br>• Нестабильная<br>• Частые изменения<br>• Для разработчиков

QA/Testing Environment	<b>QA Environment</b> — среда для проведения тестирования.<br><br><b>Характеристики:</b><br>• Стабильнее DEV<br>• Контролируемые данные<br>• Для QA-команды

Staging Environment	<b>Staging Environment</b> — среда, максимально похожая на production.<br><br><b>Характеристики:</b><br>• Копия production конфигурации<br>• Финальное тестирование<br>• UAT проводится здесь

Production Environment (PROD)	<b>Production Environment</b> — боевая среда с реальными пользователями.<br><br><b>Характеристики:</b><br>• Реальные данные<br>• Высокая стабильность<br>• Тестирование только в исключительных случаях

# ===== ВХОДНЫЕ И ВЫХОДНЫЕ КРИТЕРИИ =====

Entry Criteria (Критерии входа)	<b>Entry Criteria</b> — условия, которые должны быть выполнены до начала тестирования.<br><br><b>Примеры:</b><br>• Билд развёрнут на QA-среде<br>• Документация готова<br>• Smoke-тесты проходят

Exit Criteria (Критерии выхода)	<b>Exit Criteria</b> — условия для завершения тестирования и готовности к релизу.<br><br><b>Примеры:</b><br>• 95% тестов пройдено<br>• Нет Critical/Blocker багов<br>• Регрессия выполнена

Suspension Criteria	<b>Suspension Criteria</b> — условия для приостановки тестирования.<br><br><b>Примеры:</b><br>• Критический баг блокирует работу<br>• Среда недоступна<br>• Неполная сборка

# ===== ИНСТРУМЕНТЫ ТЕСТИРОВАНИЯ =====

Jira	<b>Jira</b> — популярная система для управления проектами и отслеживания дефектов.<br><br><b>Использование в QA:</b><br>• Создание багов<br>• Отслеживание задач<br>• Kanban/Scrum доски

TestRail	<b>TestRail</b> — инструмент для управления тест-кейсами и планами тестирования.<br><br><b>Функции:</b><br>• Хранение тест-кейсов<br>• Выполнение тестов<br>• Отчётность

Postman	<b>Postman</b> — инструмент для тестирования API.<br><br><b>Функции:</b><br>• Отправка HTTP-запросов<br>• Проверка ответов<br>• Коллекции и автоматизация

BrowserStack / Sauce Labs	<b>BrowserStack / Sauce Labs</b> — облачные платформы для кросс-браузерного тестирования.<br><br><b>Преимущества:</b><br>• Множество браузеров и устройств<br>• Не нужно содержать свою ферму

Charles Proxy / Fiddler	<b>Charles Proxy / Fiddler</b> — инструменты для анализа HTTP-трафика.<br><br><b>Применение в QA:</b><br>• Перехват запросов<br>• Модификация данных<br>• Симуляция медленной сети

# ===== SDLC И МОДЕЛИ РАЗРАБОТКИ =====

SDLC (Software Development Life Cycle)	<b>SDLC</b> — жизненный цикл разработки ПО, этапы от идеи до вывода из эксплуатации.<br><br><b>Этапы:</b><br>1. Планирование<br>2. Анализ требований<br>3. Дизайн<br>4. Разработка<br>5. Тестирование<br>6. Развёртывание<br>7. Поддержка

Waterfall Model (Водопадная модель)	<b>Waterfall</b> — последовательная модель разработки, где каждый этап выполняется полностью до перехода к следующему.<br><br><b>Особенности для QA:</b><br>• Тестирование в конце<br>• Много документации<br>• Поздняя обратная связь

Agile (Гибкая методология)	<b>Agile</b> — итеративный подход к разработке с короткими циклами и постоянной обратной связью.<br><br><b>Принципы для QA:</b><br>• Раннее тестирование<br>• Постоянная коммуникация<br>• Адаптивность

Scrum	<b>Scrum</b> — Agile-фреймворк с фиксированными итерациями (спринтами).<br><br><b>Роль QA в Scrum:</b><br>• Участие в планировании<br>• Тестирование в спринте<br>• Демо и ретроспектива

Sprint (Спринт)	<b>Sprint</b> — фиксированный период (обычно 2 недели), за который команда выполняет набор задач.<br><br><b>QA-активности:</b><br>• Тестирование user stories<br>• Регрессия в конце спринта<br>• Участие в церемониях

User Story	<b>User Story</b> — краткое описание функциональности с точки зрения пользователя.<br><br><b>Формат:</b> "Как [роль], я хочу [функция], чтобы [ценность]"<br><b>Пример:</b> "Как покупатель, я хочу фильтровать товары по цене"

Definition of Done (DoD)	<b>Definition of Done</b> — критерии, определяющие, когда задача считается завершённой.<br><br><b>Пример для QA:</b><br>• Код написан<br>• Unit-тесты есть<br>• QA тестирование пройдено<br>• Документация обновлена

Kanban	<b>Kanban</b> — визуальный метод управления работой с непрерывным потоком задач.<br><br><b>Особенности для QA:</b><br>• Нет спринтов<br>• WIP-лимиты<br>• Визуализация процесса

# ===== ТЕРМИНОЛОГИЯ ТЕСТИРОВАНИЯ =====

Test Basis	<b>Test Basis</b> — все документы, на основе которых создаются тесты.<br><br><b>Примеры:</b><br>• Требования<br>• Спецификации<br>• User Stories<br>• Дизайн-макеты

Test Oracle	<b>Test Oracle</b> — источник для определения ожидаемого результата теста.<br><br><b>Примеры:</b><br>• Требования<br>• Аналогичная система<br>• Эвристики тестировщика

Test Data (Тестовые данные)	<b>Test Data</b> — данные, используемые для выполнения тестов.<br><br><b>Типы:</b><br>• Валидные<br>• Невалидные<br>• Граничные<br>• Реальные (анонимизированные)

Test Harness	<b>Test Harness</b> — среда, включающая стабы и драйверы для выполнения тестов.<br><br><b>Компоненты:</b><br>• Stubs — имитация вызываемых модулей<br>• Drivers — имитация вызывающих модулей

Stub (Заглушка)	<b>Stub</b> — имитация компонента, который вызывается тестируемым модулем.<br><br><b>Пример:</b> Заглушка для платёжного шлюза, возвращающая "успех"

Mock (Мок)	<b>Mock</b> — объект, имитирующий поведение реального объекта с возможностью проверки вызовов.<br><br><b>Отличие от Stub:</b> Mock проверяет взаимодействие, Stub просто возвращает данные

Test Automation (Автоматизация тестирования)	<b>Test Automation</b> — использование специального ПО для выполнения тестов и сравнения результатов.<br><br><b>Когда автоматизировать:</b><br>• Повторяющиеся тесты<br>• Регрессия<br>• Smoke/Sanity

Continuous Integration (CI)	<b>CI</b> — практика частой интеграции кода в общий репозиторий с автоматической сборкой и тестами.<br><br><b>Преимущества для QA:</b><br>• Быстрая обратная связь<br>• Ранее обнаружение проблем

Continuous Delivery/Deployment (CD)	<b>CD</b> — автоматизация процесса доставки/развёртывания кода в различные среды.<br><br><b>Роль QA:</b><br>• Автотесты в пайплайне<br>• Quality gates<br>• Мониторинг качества

# ===== SOFT SKILLS ДЛЯ QA =====

Какие soft skills важны для QA?	<b>Ключевые soft skills QA:</b><br><br>1. <b>Внимание к деталям</b> — замечать мелочи<br>2. <b>Критическое мышление</b> — "А что если?"<br>3. <b>Коммуникация</b> — ясно доносить информацию<br>4. <b>Эмпатия</b> — думать как пользователь<br>5. <b>Настойчивость</b> — докапываться до истины

Как QA должен общаться с разработчиками?	<b>Правила общения с разработчиками:</b><br><br>1. Будь объективен, описывай факты<br>2. Не переходи на личности<br>3. Предлагай, а не критикуй<br>4. Уважай чужую работу<br>5. Фокусируйся на продукте, а не на ошибках человека

Что такое QA-мышление?	<b>QA-мышление</b> — способ мыслить, характерный для хорошего тестировщика:<br><br>• <b>Скептицизм</b> — "Покажи, что работает"<br>• <b>Любопытство</b> — "Почему так?"<br>• <b>Системность</b> — видеть связи<br>• <b>Эмпатия</b> — думать о пользователе

# ===== ТИПИЧНЫЕ ОШИБКИ НАЧИНАЮЩИХ QA =====

Какие ошибки допускают начинающие QA?	<b>Типичные ошибки Junior QA:</b><br><br>1. Фокус на количестве багов, а не качестве<br>2. Игнорирование бизнес-контекста<br>3. Слабые баг-репорты<br>4. Тестирование только "happy path"<br>5. Страх задавать вопросы<br>6. Перфекционизм в тестировании

Как написать хороший баг-репорт?	<b>Хороший баг-репорт содержит:</b><br><br>1. <b>Заголовок</b> — краткое описание проблемы<br>2. <b>Среда</b> — браузер, ОС, версия<br>3. <b>Шаги</b> — чёткие шаги воспроизведения<br>4. <b>Ожидаемый результат</b><br>5. <b>Фактический результат</b><br>6. <b>Доказательства</b> — скриншоты, логи

Что такое Happy Path?	<b>Happy Path</b> — основной позитивный сценарий использования системы, когда всё идёт "как надо".<br><br><b>Важно:</b> Нельзя ограничиваться только Happy Path, нужно тестировать и негативные сценарии!

# ===== ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ =====

Почему нельзя протестировать всё?	<b>Причины невозможности полного тестирования:</b><br><br>1. Бесконечное количество входных комбинаций<br>2. Ограниченные время и ресурсы<br>3. Множество путей выполнения<br>4. Различные среды и конфигурации<br><br><b>Решение:</b> Приоритизация на основе рисков

Когда начинать тестирование?	<b>Ответ:</b> Как можно раньше!<br><br><b>Почему:</b><br>• Стоимость исправления растёт со временем<br>• Баг на этапе требований исправить легче<br>• "Shift Left" — сдвиг тестирования влево<br><br><b>Активности:</b> Ревью требований, участие в планировании

В чём разница между Verification и Validation?	<b>Verification</b> — "Правильно ли мы строим продукт?"<br>Проверка соответствия спецификациям.<br><br><b>Validation</b> — "Правильный ли продукт мы строим?"<br>Проверка соответствия потребностям пользователей.

Что такое Shift Left в тестировании?	<b>Shift Left</b> — подход, при котором тестирование и QA-активности начинаются как можно раньше в цикле разработки.<br><br><b>Преимущества:</b><br>• Раннее обнаружение дефектов<br>• Снижение стоимости исправлений<br>• Улучшение качества требований

# ===== СОКРАЩЕНИЯ И АББРЕВИАТУРЫ =====

QA	Quality Assurance — Обеспечение качества

QC	Quality Control — Контроль качества

SDLC	Software Development Life Cycle — Жизненный цикл разработки ПО

STLC	Software Testing Life Cycle — Жизненный цикл тестирования ПО

UAT	User Acceptance Testing — Пользовательское приёмочное тестирование

SRS	Software Requirements Specification — Спецификация требований к ПО

RTM	Requirements Traceability Matrix — Матрица трассируемости требований

BVA	Boundary Value Analysis — Анализ граничных значений

EP	Equivalence Partitioning — Разбиение на классы эквивалентности

CI/CD	Continuous Integration / Continuous Delivery — Непрерывная интеграция и доставка

API	Application Programming Interface — Программный интерфейс приложения

GUI	Graphical User Interface — Графический интерфейс пользователя

E2E	End-to-End — Сквозное тестирование от начала до конца

POC	Proof of Concept — Проверка концепции

MVP	Minimum Viable Product — Минимально жизнеспособный продукт

DoD	Definition of Done — Определение готовности

DoR	Definition of Ready — Определение готовности к разработке

WIP	Work In Progress — Работа в процессе

SLA	Service Level Agreement — Соглашение об уровне сервиса
