#separator:tab
#html:true
#tags:Testing-Types-Levels Week3-4 Trainee

# ===== УРОВНИ ТЕСТИРОВАНИЯ (TEST LEVELS) =====

Какие существуют 4 основных уровня тестирования?	<b>4 уровня тестирования:</b><br><br>1. <b>Unit Testing</b> — модульное (компонентное)<br>2. <b>Integration Testing</b> — интеграционное<br>3. <b>System Testing</b> — системное<br>4. <b>Acceptance Testing</b> — приёмочное<br><br><b>Порядок:</b> От мелких частей к целой системе

Unit Testing: определение и цель	<b>Unit Testing (Модульное тестирование)</b><br><br><b>Определение:</b> Тестирование отдельных модулей/компонентов в изоляции<br><br><b>Цель:</b> Убедиться, что каждый модуль работает корректно независимо<br><br><b>Пример:</b> Проверка функции calculateDiscount() с разными входными параметрами

Кто выполняет Unit Testing?	<b>Кто выполняет:</b> Разработчики (Developer Testing)<br><br><b>Почему:</b><br>• Требуется доступ к коду<br>• Знание внутренней логики<br>• Быстрая обратная связь<br><br><b>Инструменты:</b> JUnit, NUnit, pytest, Jest

Что такое Component Testing?	<b>Component Testing</b> — синоним Unit Testing, тестирование отдельного компонента системы.<br><br><b>Особенности:</b><br>• Изолированное тестирование<br>• Использование моков и стабов<br>• Высокая скорость выполнения<br><br><b>Пример:</b> Тест класса UserValidator отдельно от базы данных

Integration Testing: определение и цель	<b>Integration Testing (Интеграционное тестирование)</b><br><br><b>Определение:</b> Тестирование взаимодействия между модулями/компонентами<br><br><b>Цель:</b> Проверить, что модули корректно работают вместе<br><br><b>Пример:</b> Проверка связи между модулем заказов и модулем оплаты

Какие подходы к Integration Testing существуют?	<b>Подходы к интеграционному тестированию:</b><br><br>1. <b>Big Bang</b> — все модули сразу<br>2. <b>Top-Down</b> — сверху вниз (с заглушками)<br>3. <b>Bottom-Up</b> — снизу вверх (с драйверами)<br>4. <b>Sandwich/Hybrid</b> — комбинация подходов

Big Bang Integration Testing	<b>Big Bang Integration</b> — интеграция всех модулей одновременно.<br><br><b>Плюсы:</b> Быстро для маленьких систем<br><b>Минусы:</b> Сложно локализовать ошибки<br><br><b>Когда применять:</b> Небольшие проекты с малым количеством модулей

Top-Down Integration Testing	<b>Top-Down Integration</b> — интеграция начинается с верхнего уровня.<br><br><b>Особенности:</b><br>• Используются Stubs (заглушки)<br>• Сначала тестируется основной поток<br>• Раннее обнаружение архитектурных проблем<br><br><b>Пример:</b> Тестируем UI → Бизнес-логика → заглушка для БД

Bottom-Up Integration Testing	<b>Bottom-Up Integration</b> — интеграция начинается с нижнего уровня.<br><br><b>Особенности:</b><br>• Используются Drivers (драйверы)<br>• Сначала тестируются базовые модули<br>• UI тестируется в последнюю очередь<br><br><b>Пример:</b> Тестируем БД → Бизнес-логика → UI

Sandwich (Hybrid) Integration Testing	<b>Sandwich Integration</b> — комбинация Top-Down и Bottom-Up.<br><br><b>Особенности:</b><br>• Одновременно сверху и снизу<br>• Встреча посередине<br>• Сложнее в организации<br><br><b>Когда применять:</b> Большие проекты с командами на разных уровнях

System Testing: определение и цель	<b>System Testing (Системное тестирование)</b><br><br><b>Определение:</b> Тестирование полностью интегрированной системы<br><br><b>Цель:</b> Проверить соответствие функциональным и нефункциональным требованиям<br><br><b>Пример:</b> Тестирование всего интернет-магазина: каталог + корзина + оплата + доставка

Кто выполняет System Testing?	<b>Кто выполняет:</b> QA-команда (независимая от разработки)<br><br><b>Среда:</b> Тестовая среда, максимально близкая к production<br><br><b>Охват:</b><br>• Функциональные требования<br>• Нефункциональные требования<br>• End-to-End сценарии

Acceptance Testing: определение и цель	<b>Acceptance Testing (Приёмочное тестирование)</b><br><br><b>Определение:</b> Тестирование системы с точки зрения конечного пользователя/заказчика<br><br><b>Цель:</b> Подтвердить, что система готова к использованию<br><br><b>Пример:</b> Заказчик проверяет, что система учёта сотрудников соответствует бизнес-требованиям

Какие виды Acceptance Testing существуют?	<b>Виды приёмочного тестирования:</b><br><br>1. <b>UAT</b> — User Acceptance Testing<br>2. <b>Alpha Testing</b> — внутри компании<br>3. <b>Beta Testing</b> — реальные пользователи<br>4. <b>Contract Acceptance</b> — по контракту<br>5. <b>Regulation Acceptance</b> — соответствие нормам

Чем отличается Alpha от Beta тестирования?	<b>Alpha vs Beta Testing:</b><br><br><b>Alpha:</b><br>• Внутри компании-разработчика<br>• Сотрудники, не из команды разработки<br>• Контролируемая среда<br><br><b>Beta:</b><br>• Реальные пользователи<br>• Реальные условия<br>• Получение обратной связи перед релизом

# ===== ФУНКЦИОНАЛЬНОЕ ТЕСТИРОВАНИЕ =====

Functional Testing: определение	<b>Functional Testing (Функциональное тестирование)</b><br><br><b>Определение:</b> Проверка того, ЧТО делает система<br><br><b>Основа:</b> Функциональные требования и спецификации<br><br><b>Вопрос:</b> "Делает ли система то, что должна?"<br><br><b>Пример:</b> Проверка, что кнопка "Добавить в корзину" добавляет товар

Smoke Testing: определение и применение	<b>Smoke Testing (Дымовое тестирование)</b><br><br><b>Определение:</b> Быстрая проверка основного функционала<br><br><b>Когда применять:</b><br>• После каждого нового билда<br>• После деплоя на среду<br>• Перед полным тестированием<br><br><b>Пример:</b> Проверка: Login + главная страница + создание заказа работают

Почему называется "Smoke Testing"?	<b>Происхождение термина:</b><br><br>Из электроники: при первом включении устройства проверяют, "не идёт ли дым".<br><br><b>Аналогия в ПО:</b> Проверяем, что система "не дымит" — базово работает и не падает при запуске.<br><br><b>Другое название:</b> Build Verification Testing (BVT)

Sanity Testing: определение и применение	<b>Sanity Testing (Санитарное тестирование)</b><br><br><b>Определение:</b> Узконаправленная проверка конкретной функциональности после изменений<br><br><b>Когда применять:</b><br>• После исправления бага<br>• После небольших изменений<br>• Перед регрессией<br><br><b>Пример:</b> После фикса оплаты — проверяем только модуль оплаты

Чем отличается Smoke от Sanity Testing?	<b>Smoke vs Sanity Testing:</b><br><br><b>Smoke:</b><br>• Широкий охват<br>• Основной функционал<br>• После нового билда<br>• "Система работает?"<br><br><b>Sanity:</b><br>• Узкий фокус<br>• Конкретная функция<br>• После изменений<br>• "Изменение не сломало?"

Regression Testing: определение и применение	<b>Regression Testing (Регрессионное тестирование)</b><br><br><b>Определение:</b> Проверка, что новые изменения не сломали существующий функционал<br><br><b>Когда применять:</b><br>• После любых изменений кода<br>• Перед релизом<br>• После исправления багов<br><br><b>Рекомендация:</b> Автоматизировать!

Почему регрессию нужно автоматизировать?	<b>Причины автоматизации регрессии:</b><br><br>1. <b>Частота:</b> Выполняется постоянно<br>2. <b>Объём:</b> Много повторяющихся тестов<br>3. <b>Скорость:</b> Нужен быстрый feedback<br>4. <b>Стоимость:</b> Ручное выполнение дорого<br>5. <b>Точность:</b> Меньше человеческих ошибок

Re-testing vs Regression Testing	<b>Re-testing vs Regression:</b><br><br><b>Re-testing:</b><br>• Проверка исправленного бага<br>• Узкий фокус на конкретном дефекте<br>• "Баг исправлен?"<br><br><b>Regression:</b><br>• Проверка всей системы<br>• Широкий охват<br>• "Ничего не сломалось?"

Exploratory Testing: определение	<b>Exploratory Testing (Исследовательское тестирование)</b><br><br><b>Определение:</b> Одновременное изучение, проектирование и выполнение тестов<br><br><b>Характеристики:</b><br>• Минимум документации<br>• Креативный подход<br>• Опыт тестировщика критичен<br><br><b>Когда:</b> Новая функциональность, поиск неочевидных багов

Session-Based Testing	<b>Session-Based Testing</b> — структурированный подход к исследовательскому тестированию.<br><br><b>Элементы:</b><br>• Сессия (30-120 минут)<br>• Чартер (цель сессии)<br>• Отчёт о сессии<br><br><b>Пример чартера:</b> "Исследовать модуль оплаты на предмет безопасности"

Ad-hoc Testing: определение	<b>Ad-hoc Testing</b> — неструктурированное тестирование без планирования и документации.<br><br><b>Характеристики:</b><br>• Интуитивный подход<br>• Нет чётких целей<br>• Хаотичный характер<br><br><b>Отличие от Exploratory:</b> Ad-hoc хаотичен, Exploratory структурирован

Positive Testing: определение	<b>Positive Testing (Позитивное тестирование)</b><br><br><b>Определение:</b> Тестирование с корректными входными данными<br><br><b>Цель:</b> Подтвердить, что система работает правильно<br><br><b>Пример:</b> Авторизация с верным логином и паролем → успешный вход

Negative Testing: определение	<b>Negative Testing (Негативное тестирование)</b><br><br><b>Определение:</b> Тестирование с некорректными входными данными<br><br><b>Цель:</b> Проверить обработку ошибок системой<br><br><b>Примеры:</b><br>• Пустой пароль<br>• Спецсимволы в email<br>• Отрицательное количество товара

Почему Negative Testing важен?	<b>Важность негативного тестирования:</b><br><br>1. <b>Устойчивость:</b> Система должна обрабатывать ошибки<br>2. <b>Безопасность:</b> Защита от злоумышленников<br>3. <b>UX:</b> Понятные сообщения об ошибках<br>4. <b>Стабильность:</b> Система не падает при неверных данных<br><br><b>Правило:</b> 40% тестов должны быть негативными

End-to-End Testing (E2E)	<b>End-to-End Testing</b> — тестирование полного пользовательского сценария от начала до конца.<br><br><b>Цель:</b> Проверить работу всей системы в реальных условиях<br><br><b>Пример:</b> Регистрация → Поиск товара → Добавление в корзину → Оформление заказа → Оплата → Подтверждение

Happy Path Testing	<b>Happy Path Testing</b> — тестирование основного успешного сценария без ошибок.<br><br><b>Характеристики:</b><br>• Позитивные данные<br>• Идеальные условия<br>• Ожидаемое поведение<br><br><b>Важно:</b> Недостаточно тестировать только Happy Path!

Альтернативные пути (Alternative Paths)	<b>Alternative Paths</b> — допустимые отклонения от основного сценария.<br><br><b>Примеры:</b><br>• Оплата картой ИЛИ наличными<br>• Доставка курьером ИЛИ самовывоз<br>• Регистрация через email ИЛИ соцсети<br><br><b>Важно:</b> Все альтернативные пути нужно тестировать

# ===== НЕФУНКЦИОНАЛЬНОЕ ТЕСТИРОВАНИЕ =====

Non-Functional Testing: определение	<b>Non-Functional Testing (Нефункциональное тестирование)</b><br><br><b>Определение:</b> Проверка КАК работает система (качественные характеристики)<br><br><b>Примеры:</b><br>• Производительность<br>• Безопасность<br>• Удобство<br>• Надёжность<br><br><b>Вопрос:</b> "Насколько хорошо система это делает?"

Performance Testing: определение	<b>Performance Testing (Тестирование производительности)</b><br><br><b>Определение:</b> Проверка скорости, стабильности и масштабируемости системы<br><br><b>Метрики:</b><br>• Response Time<br>• Throughput<br>• Resource Utilization<br><br><b>Инструменты:</b> JMeter, Gatling, LoadRunner

Виды Performance Testing	<b>Виды тестирования производительности:</b><br><br>1. <b>Load Testing</b> — под ожидаемой нагрузкой<br>2. <b>Stress Testing</b> — предельная нагрузка<br>3. <b>Spike Testing</b> — резкие скачки<br>4. <b>Endurance Testing</b> — длительная нагрузка<br>5. <b>Scalability Testing</b> — масштабируемость

Load Testing: определение	<b>Load Testing (Нагрузочное тестирование)</b><br><br><b>Определение:</b> Проверка поведения системы под ожидаемой нагрузкой<br><br><b>Цель:</b> Убедиться, что система справляется с типичной нагрузкой<br><br><b>Пример:</b> 1000 одновременных пользователей на сайте в течение часа

Stress Testing: определение	<b>Stress Testing (Стрессовое тестирование)</b><br><br><b>Определение:</b> Проверка системы за пределами нормальной нагрузки<br><br><b>Цель:</b> Найти точку отказа и поведение при перегрузке<br><br><b>Пример:</b> Увеличение пользователей до момента падения системы

Spike Testing: определение	<b>Spike Testing (Тестирование пиков)</b><br><br><b>Определение:</b> Проверка реакции на резкие скачки нагрузки<br><br><b>Цель:</b> Убедиться, что система выдерживает внезапные всплески<br><br><b>Пример:</b> Black Friday — резкий рост посетителей в 10 раз за минуту

Endurance Testing (Soak Testing)	<b>Endurance Testing (Тестирование стабильности)</b><br><br><b>Определение:</b> Длительное тестирование под нормальной нагрузкой<br><br><b>Цель:</b> Выявить утечки памяти, деградацию производительности<br><br><b>Пример:</b> Работа системы 24 часа непрерывно под средней нагрузкой

Scalability Testing	<b>Scalability Testing (Тестирование масштабируемости)</b><br><br><b>Определение:</b> Проверка способности системы масштабироваться<br><br><b>Цель:</b> Определить, как добавление ресурсов влияет на производительность<br><br><b>Пример:</b> Как меняется производительность при добавлении второго сервера?

Security Testing: определение	<b>Security Testing (Тестирование безопасности)</b><br><br><b>Определение:</b> Проверка защищённости системы от угроз<br><br><b>Аспекты:</b><br>• Конфиденциальность<br>• Целостность<br>• Доступность<br>• Аутентификация<br>• Авторизация<br><br><b>Инструменты:</b> OWASP ZAP, Burp Suite

Виды Security Testing	<b>Виды тестирования безопасности:</b><br><br>1. <b>Vulnerability Scanning</b> — поиск уязвимостей<br>2. <b>Penetration Testing</b> — имитация атак<br>3. <b>Security Audit</b> — аудит кода и конфигурации<br>4. <b>Risk Assessment</b> — оценка рисков<br>5. <b>Ethical Hacking</b> — контролируемый взлом

Penetration Testing	<b>Penetration Testing (Пентест)</b> — имитация реальной атаки на систему.<br><br><b>Цель:</b> Найти уязвимости до злоумышленников<br><br><b>Кто выполняет:</b> Специалисты по безопасности (пентестеры)<br><br><b>Результат:</b> Отчёт с уязвимостями и рекомендациями

OWASP Top 10	<b>OWASP Top 10</b> — список 10 наиболее критичных уязвимостей веб-приложений.<br><br><b>Примеры:</b><br>• SQL Injection<br>• Cross-Site Scripting (XSS)<br>• Broken Authentication<br>• Sensitive Data Exposure<br><br><b>Использование:</b> Чеклист для Security Testing

Usability Testing: определение	<b>Usability Testing (Тестирование удобства)</b><br><br><b>Определение:</b> Проверка того, насколько легко пользователи могут использовать систему<br><br><b>Аспекты:</b><br>• Интуитивность<br>• Эффективность<br>• Удовлетворённость<br>• Обучаемость<br><br><b>Метод:</b> Наблюдение за реальными пользователями

Аспекты Usability	<b>5 аспектов Usability (по Nielsen):</b><br><br>1. <b>Learnability</b> — легко освоить<br>2. <b>Efficiency</b> — быстрое выполнение задач<br>3. <b>Memorability</b> — легко вспомнить<br>4. <b>Errors</b> — мало ошибок пользователя<br>5. <b>Satisfaction</b> — приятно использовать

Accessibility Testing	<b>Accessibility Testing (Тестирование доступности)</b><br><br><b>Определение:</b> Проверка доступности для людей с ограниченными возможностями<br><br><b>Аспекты:</b><br>• Работа со screen reader<br>• Контрастность<br>• Навигация с клавиатуры<br>• Альтернативный текст<br><br><b>Стандарт:</b> WCAG 2.1

Compatibility Testing: определение	<b>Compatibility Testing (Тестирование совместимости)</b><br><br><b>Определение:</b> Проверка работы системы в разных средах<br><br><b>Типы:</b><br>• Браузеры<br>• Операционные системы<br>• Устройства<br>• Версии ПО<br><br><b>Инструменты:</b> BrowserStack, Sauce Labs

Cross-Browser Testing	<b>Cross-Browser Testing</b> — проверка работы в разных браузерах.<br><br><b>Основные браузеры:</b><br>• Chrome<br>• Firefox<br>• Safari<br>• Edge<br><br><b>Что проверять:</b> Вёрстка, функциональность, производительность

Cross-Platform Testing	<b>Cross-Platform Testing</b> — проверка работы на разных платформах.<br><br><b>Платформы:</b><br>• Windows / macOS / Linux<br>• iOS / Android<br>• Desktop / Mobile / Tablet<br><br><b>Важно:</b> Одинаковый UX на всех платформах

Reliability Testing	<b>Reliability Testing (Тестирование надёжности)</b><br><br><b>Определение:</b> Проверка стабильной работы системы без сбоев<br><br><b>Метрики:</b><br>• MTBF — среднее время между отказами<br>• MTTR — среднее время восстановления<br><br><b>Пример:</b> Система работает 99.9% времени (SLA)

Recovery Testing	<b>Recovery Testing (Тестирование восстановления)</b><br><br><b>Определение:</b> Проверка способности системы восстанавливаться после сбоев<br><br><b>Сценарии:</b><br>• Отключение питания<br>• Сбой сети<br>• Crash базы данных<br><br><b>Что проверять:</b> Время восстановления, сохранность данных

Failover Testing	<b>Failover Testing</b> — проверка автоматического переключения на резервную систему.<br><br><b>Цель:</b> Убедиться, что при отказе основной системы резервная берёт нагрузку<br><br><b>Пример:</b> При падении сервера 1 трафик автоматически идёт на сервер 2

Localization Testing	<b>Localization Testing (Тестирование локализации)</b><br><br><b>Определение:</b> Проверка адаптации продукта для конкретного региона/языка<br><br><b>Аспекты:</b><br>• Перевод текстов<br>• Форматы дат и валют<br>• Культурные особенности<br><br><b>Пример:</b> Проверка русской версии сайта

Internationalization Testing (i18n)	<b>Internationalization Testing</b> — проверка готовности продукта к локализации.<br><br><b>Аспекты:</b><br>• Поддержка Unicode<br>• Изменяемые форматы дат<br>• RTL языки (арабский, иврит)<br>• Расширяемые UI-элементы<br><br><b>Отличие от Localization:</b> i18n — архитектура, L10n — контент

# ===== КЛАССИФИКАЦИИ ТЕСТИРОВАНИЯ =====

Black Box Testing: определение	<b>Black Box Testing (Тестирование чёрного ящика)</b><br><br><b>Определение:</b> Тестирование без знания внутренней структуры<br><br><b>Фокус:</b> Входы и выходы системы<br><br><b>Кто использует:</b> QA-инженеры<br><br><b>Техники:</b> Equivalence Partitioning, BVA, Decision Tables

White Box Testing: определение	<b>White Box Testing (Тестирование белого ящика)</b><br><br><b>Определение:</b> Тестирование с доступом к исходному коду<br><br><b>Фокус:</b> Логика кода, ветвления, циклы<br><br><b>Кто использует:</b> Разработчики<br><br><b>Техники:</b> Statement Coverage, Branch Coverage, Path Testing

Gray Box Testing: определение	<b>Gray Box Testing (Тестирование серого ящика)</b><br><br><b>Определение:</b> Комбинация Black Box и White Box подходов<br><br><b>Знание:</b> Частичное понимание архитектуры<br><br><b>Пример:</b> QA тестирует API, зная структуру базы данных

Black Box vs White Box vs Gray Box	<b>Сравнение подходов:</b><br><br><b>Black Box:</b> Что делает? (QA)<br><b>White Box:</b> Как работает? (Dev)<br><b>Gray Box:</b> Комбинация (QA + знание архитектуры)<br><br><b>Покрытие:</b><br>Black → функциональное<br>White → code coverage<br>Gray → интеграционное

Static Testing: определение	<b>Static Testing (Статическое тестирование)</b><br><br><b>Определение:</b> Проверка артефактов БЕЗ выполнения кода<br><br><b>Что проверяется:</b><br>• Требования<br>• Дизайн<br>• Код (code review)<br>• Тест-кейсы<br><br><b>Техники:</b> Review, Walkthrough, Inspection

Dynamic Testing: определение	<b>Dynamic Testing (Динамическое тестирование)</b><br><br><b>Определение:</b> Тестирование С выполнением кода<br><br><b>Что проверяется:</b><br>• Функциональность<br>• Производительность<br>• Поведение системы<br><br><b>Пример:</b> Запуск приложения и проверка функций

Static vs Dynamic Testing	<b>Static vs Dynamic Testing:</b><br><br><b>Static:</b><br>• Без выполнения кода<br>• Раннее обнаружение<br>• Дешевле исправлять<br>• Reviews, анализ<br><br><b>Dynamic:</b><br>• С выполнением кода<br>• Проверка поведения<br>• Реальные сценарии

Manual vs Automated Testing	<b>Manual vs Automated Testing:</b><br><br><b>Manual:</b><br>• Человек выполняет тесты<br>• Гибкость<br>• Исследовательское тестирование<br>• UX оценка<br><br><b>Automated:</b><br>• Скрипты выполняют тесты<br>• Скорость и повторяемость<br>• Регрессия<br>• Большие объёмы

Когда автоматизировать тесты?	<b>Когда автоматизировать:</b><br><br>✅ Повторяющиеся тесты<br>✅ Регрессионное тестирование<br>✅ Smoke/Sanity тесты<br>✅ Data-driven тесты<br>✅ Тесты производительности<br><br>❌ Одноразовые тесты<br>❌ Часто меняющийся функционал<br>❌ Usability тестирование

Confirmation Testing	<b>Confirmation Testing (Подтверждающее тестирование)</b><br><br><b>Определение:</b> Повторное тестирование после исправления дефекта<br><br><b>Синоним:</b> Re-testing<br><br><b>Цель:</b> Подтвердить, что дефект действительно исправлен<br><br><b>Следующий шаг:</b> Regression Testing

# ===== ПРАКТИЧЕСКИЕ СЦЕНАРИИ =====

Когда применять Smoke Testing? (сценарий)	<b>Сценарий:</b> Утро, разработчики выпустили новый билд.<br><br><b>Действие QA:</b> Запустить Smoke Test (15-30 минут):<br>• Авторизация работает?<br>• Главная страница загружается?<br>• Основные функции доступны?<br><br><b>Результат:</b> Да → продолжаем тестирование. Нет → билд отклонён

Когда применять Sanity Testing? (сценарий)	<b>Сценарий:</b> Разработчик исправил баг в модуле корзины.<br><br><b>Действие QA:</b> Sanity Test модуля корзины:<br>• Добавление товара<br>• Изменение количества<br>• Удаление товара<br>• Расчёт суммы<br><br><b>Результат:</b> Исправление не сломало модуль → регрессия

Когда применять Regression Testing? (сценарий)	<b>Сценарий:</b> В спринте добавили новую функцию "Wishlist".<br><br><b>Действие QA:</b> Регрессионное тестирование:<br>• Все существующие функции<br>• Интеграция с новой функцией<br>• Автоматизированные тесты<br><br><b>Цель:</b> Wishlist не сломал корзину, оплату, профиль

Когда применять Exploratory Testing? (сценарий)	<b>Сценарий:</b> Новый модуль "Рекомендации товаров", документация неполная.<br><br><b>Действие QA:</b> Исследовательское тестирование (1-2 часа):<br>• Изучить поведение<br>• Попробовать разные сценарии<br>• Найти неочевидные баги<br><br><b>Результат:</b> Понимание модуля + список багов

Сценарий E2E тестирования интернет-магазина	<b>E2E сценарий для e-commerce:</b><br><br>1. Регистрация нового пользователя<br>2. Вход в аккаунт<br>3. Поиск товара<br>4. Добавление в корзину<br>5. Применение промокода<br>6. Оформление заказа<br>7. Выбор доставки и оплаты<br>8. Подтверждение заказа<br>9. Получение email

Сценарий Performance Testing для API	<b>Сценарий Load Testing для API:</b><br><br><b>Цель:</b> Проверить API при 500 RPS<br><br><b>Шаги:</b><br>1. Настроить JMeter/Gatling<br>2. Создать сценарий запросов<br>3. Постепенно увеличивать нагрузку<br>4. Мониторить Response Time<br>5. Анализировать метрики<br><br><b>Критерий успеха:</b> RT < 200ms при 500 RPS

Сценарий Security Testing для формы логина	<b>Сценарий Security Testing для Login:</b><br><br><b>Проверки:</b><br>1. SQL Injection в полях<br>2. XSS в полях ввода<br>3. Brute Force защита<br>4. Безопасность сессии<br>5. HTTPS используется<br>6. Пароль не в URL<br>7. Сообщения об ошибках неинформативны

# ===== СРАВНЕНИЯ И ОТЛИЧИЯ =====

Verification vs Validation	<b>Verification vs Validation:</b><br><br><b>Verification:</b> "Правильно ли мы строим продукт?"<br>• Проверка соответствия спецификациям<br>• Статические методы<br><br><b>Validation:</b> "Правильный ли продукт мы строим?"<br>• Проверка соответствия потребностям<br>• Динамические методы

Functional vs Non-Functional Testing	<b>Functional vs Non-Functional:</b><br><br><b>Functional:</b><br>• ЧТО делает система<br>• Функции и возможности<br>• Основа: требования<br><br><b>Non-Functional:</b><br>• КАК работает система<br>• Качественные характеристики<br>• Основа: SLA, стандарты

Unit vs Integration Testing	<b>Unit vs Integration Testing:</b><br><br><b>Unit:</b><br>• Отдельный модуль<br>• Изоляция (моки)<br>• Разработчики<br>• Быстрые тесты<br><br><b>Integration:</b><br>• Связь между модулями<br>• Реальные зависимости<br>• QA/Dev<br>• Медленнее Unit

System vs Acceptance Testing	<b>System vs Acceptance Testing:</b><br><br><b>System:</b><br>• Полная система<br>• Все требования<br>• QA-команда<br>• Техническая перспектива<br><br><b>Acceptance:</b><br>• Бизнес-сценарии<br>• Готовность к релизу<br>• Заказчик/Пользователи<br>• Бизнес-перспектива

Alpha vs Beta vs GA (General Availability)	<b>Этапы релиза:</b><br><br><b>Alpha:</b><br>• Внутреннее тестирование<br>• Много багов<br>• Неполный функционал<br><br><b>Beta:</b><br>• Внешние пользователи<br>• Меньше критичных багов<br>• Почти полный функционал<br><br><b>GA:</b><br>• Официальный релиз<br>• Стабильная версия

Load vs Stress vs Spike Testing	<b>Сравнение нагрузочного тестирования:</b><br><br><b>Load:</b> Ожидаемая нагрузка (1000 users)<br><b>Цель:</b> Справляется ли система?<br><br><b>Stress:</b> Превышение лимитов (5000 users)<br><b>Цель:</b> Где точка отказа?<br><br><b>Spike:</b> Резкий скачок (100→2000 за минуту)<br><b>Цель:</b> Выдержит ли всплеск?

# ===== ИНСТРУМЕНТЫ ПО ТИПАМ ТЕСТИРОВАНИЯ =====

Инструменты для Performance Testing	<b>Инструменты Performance Testing:</b><br><br>• <b>JMeter</b> — бесплатный, популярный<br>• <b>Gatling</b> — код на Scala, отчёты<br>• <b>LoadRunner</b> — enterprise решение<br>• <b>k6</b> — современный, скрипты на JS<br>• <b>Locust</b> — Python-based

Инструменты для Security Testing	<b>Инструменты Security Testing:</b><br><br>• <b>OWASP ZAP</b> — бесплатный сканер<br>• <b>Burp Suite</b> — профессиональный инструмент<br>• <b>Nessus</b> — vulnerability scanner<br>• <b>SQLMap</b> — SQL injection тестирование<br>• <b>Nikto</b> — web server scanner

Инструменты для Accessibility Testing	<b>Инструменты Accessibility Testing:</b><br><br>• <b>WAVE</b> — браузерное расширение<br>• <b>axe</b> — автоматизированная проверка<br>• <b>Lighthouse</b> — аудит в Chrome<br>• <b>NVDA/JAWS</b> — screen readers<br>• <b>Color Contrast Analyzer</b> — проверка контраста

Инструменты для Cross-Browser Testing	<b>Инструменты Cross-Browser Testing:</b><br><br>• <b>BrowserStack</b> — облачная платформа<br>• <b>Sauce Labs</b> — облако + автоматизация<br>• <b>LambdaTest</b> — альтернатива<br>• <b>CrossBrowserTesting</b> — скриншоты<br>• <b>Browser DevTools</b> — эмуляция

# ===== МЕТРИКИ И КРИТЕРИИ =====

Метрики производительности	<b>Ключевые метрики Performance:</b><br><br>• <b>Response Time</b> — время ответа<br>• <b>Throughput</b> — запросов в секунду<br>• <b>Error Rate</b> — процент ошибок<br>• <b>CPU/Memory Usage</b> — ресурсы<br>• <b>Concurrent Users</b> — одновременные пользователи

Критерии выбора типа тестирования	<b>Как выбрать тип тестирования:</b><br><br>1. <b>Цель:</b> Что хотим проверить?<br>2. <b>Стадия:</b> На каком этапе проект?<br>3. <b>Риски:</b> Что критично?<br>4. <b>Ресурсы:</b> Время и бюджет<br>5. <b>Требования:</b> Что говорит заказчик?<br><br><b>Подход:</b> Комбинация разных типов

Пирамида тестирования	<b>Пирамида тестирования:</b><br><br><b>Основание (много):</b> Unit Tests<br>• Быстрые, дешёвые, много<br><br><b>Середина (средне):</b> Integration Tests<br>• Проверка связей<br><br><b>Вершина (мало):</b> E2E/UI Tests<br>• Медленные, дорогие, мало<br><br><b>Соотношение:</b> 70% / 20% / 10%

# ===== ТЕРМИНОЛОГИЯ И АББРЕВИАТУРЫ =====

BVT	<b>BVT — Build Verification Testing</b><br><br>Синоним Smoke Testing. Проверка, что билд "жизнеспособен" для дальнейшего тестирования.

BAT	<b>BAT — Build Acceptance Testing</b><br><br>Приёмка билда QA-командой перед началом тестирования. Аналог Smoke/BVT.

NFT	<b>NFT — Non-Functional Testing</b><br><br>Тестирование нефункциональных требований: производительность, безопасность, удобство.

SIT	<b>SIT — System Integration Testing</b><br><br>Тестирование интеграции на уровне всей системы, проверка взаимодействия всех компонентов.

UAT	<b>UAT — User Acceptance Testing</b><br><br>Пользовательское приёмочное тестирование. Конечные пользователи проверяют соответствие бизнес-требованиям.

OAT	<b>OAT — Operational Acceptance Testing</b><br><br>Операционное приёмочное тестирование. Проверка готовности к эксплуатации: бэкапы, мониторинг, восстановление.

RTM	<b>RTM — Requirements Traceability Matrix</b><br><br>Матрица отслеживания требований. Связывает требования с тест-кейсами для обеспечения полного покрытия.

SLA	<b>SLA — Service Level Agreement</b><br><br>Соглашение об уровне сервиса. Определяет метрики качества: uptime 99.9%, response time < 200ms.

MTBF и MTTR	<b>MTBF и MTTR:</b><br><br><b>MTBF</b> — Mean Time Between Failures<br>Среднее время между отказами<br><br><b>MTTR</b> — Mean Time To Recovery<br>Среднее время восстановления<br><br><b>Цель:</b> Высокий MTBF, низкий MTTR

RTO и RPO	<b>RTO и RPO:</b><br><br><b>RTO</b> — Recovery Time Objective<br>Максимально допустимое время восстановления<br><br><b>RPO</b> — Recovery Point Objective<br>Максимально допустимая потеря данных<br><br><b>Пример:</b> RTO = 1 час, RPO = 15 минут

# ===== ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ =====

Какие тесты запустить после деплоя?	<b>После деплоя запустить:</b><br><br>1. <b>Smoke Tests</b> — базовая работоспособность<br>2. <b>Sanity Tests</b> — изменённые области<br>3. <b>Regression Suite</b> — автоматизированный<br>4. <b>E2E критические пути</b><br><br><b>Порядок:</b> Smoke → Sanity → Regression → E2E

Как выбрать между Manual и Automated?	<b>Критерии выбора:</b><br><br><b>Автоматизируй:</b><br>• Частое выполнение<br>• Стабильный функционал<br>• Большие данные<br>• Регрессия<br><br><b>Вручную:</b><br>• Одноразовые тесты<br>• UX/Usability<br>• Exploratory<br>• Новый функционал

Почему важно тестировать на разных уровнях?	<b>Важность многоуровневого тестирования:</b><br><br>1. <b>Unit:</b> Ловит баги в логике рано и дёшево<br>2. <b>Integration:</b> Проверяет связи между модулями<br>3. <b>System:</b> Проверяет систему целиком<br>4. <b>Acceptance:</b> Подтверждает бизнес-ценность<br><br><b>Результат:</b> Комплексное покрытие рисков

Что проверять при Compatibility Testing?	<b>Checklist Compatibility Testing:</b><br><br>☐ Chrome / Firefox / Safari / Edge<br>☐ Windows / macOS / Linux<br>☐ iOS / Android<br>☐ Desktop / Tablet / Mobile<br>☐ Разные разрешения экрана<br>☐ Разные версии браузеров<br>☐ С включённым/выключённым JS

Как организовать тестирование нового модуля?	<b>План тестирования нового модуля:</b><br><br>1. <b>Изучить требования</b><br>2. <b>Exploratory Testing</b> — понять функционал<br>3. <b>Написать тест-кейсы</b><br>4. <b>Positive Testing</b> — Happy Path<br>5. <b>Negative Testing</b> — граничные случаи<br>6. <b>Integration Testing</b> — связь с системой<br>7. <b>Regression</b> — влияние на существующее
